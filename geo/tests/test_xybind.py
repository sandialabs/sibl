"""This module is a unit test of the xybind module.

To run
> conda activate siblenv
> cd ~/sibl/geo/src/bind
> pip install -e .  # assumes already pip installed

> cd ~/sibl/geo/tests

To run a single test, for example, the `test_version` test:
> pytest test_xybind.py::test_ptg_version -v  # to run a single test

To run all tests in this module:
> pytest test_xybind.py -v  # to run all tests
"""

# import pytest
from pathlib import Path

from ptg import command_line
import xybind as xyb
import math


def test_ptg_version():
    ptg_version = command_line.version()
    assert ptg_version == "0.0.11"


def test_xyb_version():
    assert xyb.__version__ == "0.0.8"


def test_add():
    known = 7
    found = xyb.add(3, 4)
    assert known == found


def test_subtract():
    assert xyb.subtract(1, 2) == -1


def test_attributes():
    known = 42
    found = xyb.the_answer
    assert known == found

    known = 0
    found = xyb.zero
    assert known == found


def test_power():
    """This tests an example where keyword only arguments 'base' and 'exponent' are
    required by the `xyb.exponent` method.
    """
    a, b = 2.0, 3.0
    known = a**b  # 2 ** 3 = 8

    found = xyb.exponent(base=a, exponent=b)
    assert known == found

    assert isinstance(found, float)


def test_pet():
    """This tests and example of a class with
    a constructor that takes a string as name,
    and a property used to recalled the name.
    """
    known = "Alice"
    p = xyb.Pet("Alice")
    found = p.name
    assert known == found

    # overwrite the name
    new_known = "Bob"
    p.name = "Bob"
    found = p.name
    assert new_known == found


def test_unit_square_contains():
    """Tests if simple points are in the unit square via the xybind library."""

    # boundary coordinates
    bx = [0.0, 1.0, 1.0, 0.0]
    by = [0.0, 0.0, 1.0, 1.0]

    # boundary = xyb.Parade(bx, by)
    poly = xyb.Polygon(bx, by)

    # probe coordinates
    # TODO: need to investigate edge cases on boundary, since (1, 1) is known True
    # but tests as False.
    px = [-0.5, 0.0, 0.5, 0.9, 1.5]
    py = px

    known = [False, True, True, True, False]

    found = poly.contains(probe_x=px, probe_y=py)

    assert known == found

    # # pairs = ((0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0))  # closed boundary in 2D counter-clockwise
    # pairs = (
    #     (0.0, 0.0),
    #     (0.0, 1.0),
    #     (1.0, 1.0),
    #     (1.0, 0.0),
    # )  # closed boundary in 2D but clockwise
    # coords = pg.coordinates(pairs=pairs)

    # pgon = pg.Polygon2D(boundary=coords)
    # assert len(pgon._boundary) == 4

    # # test points that are either contained in the boundary or not
    # # points = pg.coordinates(pairs=((0.5, 0.5), (1.5, 1.5)))
    # points = pg.coordinates(pairs=((0.0, 0.0), (1.0, 1.0)))

    # known = (True, False)
    # found = pgon.contains(points=points)

    # assert known == found


def test_unit_squares_inType():
    """Tests if simple points define an IN or OUT loop via the xybind library."""

    # boundary coordinates nan separated squares CCW, CW, CCW
    bx = [
        0.0,
        1.0,
        1.0,
        0.0,
        float("nan"),
        0.0,
        0.0,
        1.0,
        1.0,
        float("nan"),
        0.0,
        1.0,
        1.0,
        0.0,
    ]
    by = [
        0.0,
        0.0,
        1.0,
        1.0,
        float("nan"),
        0.0,
        1.0,
        1.0,
        0.0,
        float("nan"),
        0.0,
        0.0,
        1.0,
        1.0,
    ]

    poly = xyb.Polygon(bx, by)

    px = [-1, 0, 1, 2, 3]

    # out of index, CCW, CW, CCW, out of index
    known = [0, 1, -1, 1, 0]

    found = poly.inType(probe=px)

    assert known == found


def test_qt_node_counts():
    """Tests the number of nodes generated by different resolutions via the xybind library."""

    bx = [0.5]
    by = [0.5]

    qt = xyb.QT(bx, by)

    px = [2, 1, 0.5, 0.25]

    #
    known = [9, 14, 41, 74]

    found = qt.nodeSize(probe=px)

    assert known == found


def test_unit_circle_quad_mesh():
    """Tests if quad mesh is generated on unit circle via the xybind library."""

    # bx = [0] * 360
    # by = [0] * 360
    # for th in range(360):
    #    bx[th] = math.cos(th * math.pi / 180.0)
    #    by[th] = math.sin(th * math.pi / 180.0)

    n_samples = 360  # number of discrete sample points
    radius = 1.0
    ts = tuple(range(n_samples))  # pseudo-time parameter
    # create a boundary with x and y points
    xs = [radius * math.cos(2.0 * math.pi * t / n_samples) for t in ts]
    ys = [radius * math.sin(2.0 * math.pi * t / n_samples) for t in ts]

    # mesh = xyb.QuadMesh(bx, by)
    # mesh = xyb.QuadMesh(xs, ys)  # xybind version 0.0.7 API
    # mesh.compute(resolution=1)  # xybind version 0.0.7 API
    mesh = xyb.QuadMesh()
    output_file_basename = "test_unit_circle"
    output_file_fullname = output_file_basename + ".inp"
    mesh.initialize(
        boundary_xs=xs,
        boundary_ys=ys,
        boundary_refine=False,
        resolution=1.0,
        lower_bound_x=-1.5,
        lower_bound_y=-1.5,
        upper_bound_x=1.5,
        upper_bound_y=1.5,
        developer_output=False,
        output_file=output_file_basename,
    )

    mesh.compute()

    nds = mesh.nodes()
    con = mesh.connectivity()

    # out of index, CCW, CW, CCW, out of index
    nnp, nel = 33, 20  # number of nodal points, number of elements
    known = (nnp, nel)

    found = (len(nds), len(con))

    assert known == found

    # The `test_unit_circle.inp` file gets written to `~/sibl/test_unit_circle.inp`
    # so clean up by removing this file after the test.
    sibl_path = Path(__file__).parents[2]
    path_file_inp = sibl_path.joinpath(output_file_fullname)
    # check that the file exists and has been written to the ~/sibl folder
    assert path_file_inp.is_file()
    path_file_inp.unlink()  # delete the file
    assert not path_file_inp.is_file()  # check that the file no longer exists
